import("//build/compiled_action.gni")
import("//rust.gni")

template("rust_flatbuffer") {
  assert(defined(invoker.sources), "Need sources for flatbuffers_library")

  # Don't apply OS-specific sources filtering to the assignments later on.
  # Platform files should have gotten filtered out in the sources assignment
  # when this template was invoked. If they weren't, it was on purpose and
  # this template shouldn't re-apply the filter.
  set_sources_assignment_filter([])

  action_name = "${target_name}_gen"
  source_set_name = target_name
  compiled_action_foreach(action_name) {
    visibility = [ ":$source_set_name" ]

    tool = "//third_party/flatbuffers:flatc"

    sources = invoker.sources
    deps = []

    if (defined(invoker.flatc_out_dir)) {
      out_dir = "$root_gen_dir/" + invoker.flatc_out_dir
    } else {
      out_dir = "{{source_gen_dir}}"
    }

    outputs = [
      "$out_dir/{{source_name_part}}_generated.rs",
    ]

    args = [
      "--rust",
      "--keep-prefix",
      "-o",
      "$out_dir",
      "-I",
      rebase_path("//", root_build_dir),
    ]

    if (defined(invoker.flatc_include_dirs)) {
      foreach(include_dir, invoker.flatc_include_dirs) {
        args += [
          "-I",
          rebase_path(include_dir, root_build_dir),
        ]
      }
    }

    args += [ "{{source}}" ]

    # The deps may have steps that have to run before running flatc.
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }
  }

  rust_library(target_name) {
    forward_variables_from(invoker, [ "visibility" ])
    sources = get_target_outputs(":$action_name")
    source_root = sources[0]
    if (defined(invoker.testonly)) {
      testonly = invoker.testonly
    }
    rust_deps = [
      "//third_party/flatbuffers/rust:flatbuffers",
    ]
    deps = [
      ":$action_name",
    ]
  }
}
